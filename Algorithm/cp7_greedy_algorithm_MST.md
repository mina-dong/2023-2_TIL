# 그리디 알고리즘 : 탐욕알고리즘
optimization problem 최적화 문제에서 많이 사용하는 알고리즘임.  
매 알고리즘 **스텝마다 현재 상태에서 최적의 해**를 만드는 것을 선택함.  


## Number selection 
n개의 숫자를 가지고 있을 때, 이 수들의 합이 최대가 되도록 m개를 고르는 알고리즘? (  m <= n)?  

이때 n을 6,(총 6개의 숫자를 가짐) m을 3이라고 가정한다(3개를 선택하기)  

그리드 알고리즘 : 매 step 마다 남아있는 숫자에서 제일 큰 숫자를 선택하고, m번 반복한다.   

### 증명하기(귀류법)  
claim : 그리디 알고리즘은 최적의 해다.
집합 s = {n1,..nm}를 그리디 알고리즘으로 뽑은 n개의 숫자들의 집합이라 하고,  
s가 원소의 합이 최대가 아니라고 한다. 즉, 최적의 해가 아니라고 하자. 

그러면 선택하지 않은 수 n'이 최적을 이루는 숫자가 된다. 
집합 s' = s - {nm} U {n'} 의 원소들의 합은 S의 원소들의 합보다 커야하는데,
이는 그리디알고리즘에 모순이 되므로 그리디 알고리즘은 최적의 해이다.
(nm은 언제나 바구니에서 m번째로 큰 수이기 때문이다.)

## MST minimum spanning tree
connected graph G = (V(G), E(G)). v = vertex E = edge.  
각 엣지에는 cost(weight)가 주어져 있다.(각 cods는 0보다 크고, V(G)의 절대값은 n, E(G)의 절대값은 m이라고 한다.)

### 목표 : 조건을 만족하는 g' = (v(g), T) 찾기 
조건1 - g'은 connected.  ( 모든 vertex가 연결되어 있다.)
조건2 - g'은 포함하는 edge들의 cost의 총 합을 최소로 할 것.

- g'의 엣지 T를 선택하는 과정에서 T가 사이클을 포함하고 있을 때,
  해당 사이클에서 아무 엣지나 제거해도,
  g'은 **여전히 연결되어 있다**.
  즉, edge cost의 총합은 줄어든다.

- g'은 사이클이 없고 연결되어 있는 형태의 트리가 된다.

두가지 조건을 만족한 경우 MST라고 하며, 조건 1(모든 버텍스가 연결되어있다)만 만족하는 경우, g'을 g의 spining tree라고 한다.  


